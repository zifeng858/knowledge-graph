

##二、多线程部分
### 1.什么是线程安全性
 当多个线程访问某个类, 不管运行环境采用何种调度方式或者这些线程如何交替执行, 并且在主调代码中不需要任何额外的同步或协同, 这个类都能表现出正确的行为, 那么就称这个类为线程安全的。
 ***
### 2.如何保证线程安全性，如何安全的共享对象
 1、使用线程安全的类；
 2、使用synchronized同步代码块，或者用Lock锁；
 3、多线程并发情况下，线程共享的变量改为方法局部级变量；

线程共享安全策略：
线程限制：一个被线程限制的对象，由线程独占，并且只能被占用它的线程修改。
共享只读：一个共享只读对象，在没有额外同步修改的情况下，可以被多个线程并发访问，但是任何线程都不能修改它。
***
### 3.Synchronized和volatile的区别
1.  volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取。synchronized则是锁定当前变量，只有当前线程可以访问该变量，其它线程被阻塞。
2. volatile仅能使用在变量级别，synchronized则可以使用在变量、方法。
3. volatile仅能实现变量修改的可见性，而synchronized则可以保证变量修改的可见性和原子性。《Java编程思想》上说，定义long或double时，如果使用volatile关键字(简单的赋值与返回操作)，就会获得原子性。(常规状态下，这两个变量由于其长度，其操作不是原子的)
4. volatile不会造成线程阻塞，synchronized会造成线程阻塞。
5. 使用volatile而不是synchronized的唯一安全情况是类中只有一个可变的域。

***
### 4.并发包内容 CurrentHashMap、CopyOnWriteArrayList、信号量、栅栏、CountDownlatch、Atomic类的作用实现原理及其使用场景

*** 
### 5.谈谈死锁、活锁、线程饥饿如何产生的，及如何避免
### 6.Lock的作用，重入锁、读写锁底层实现原理，AQS、CAS
### 7.讲讲各种jdk中队列，及时使用场景
### 8.阻塞队列和非阻塞队列分别如何实现的
### 9.自定义线程池每个参数的作用，线程池的生命周期，返回结果，和线程中断等如何实现
### 10.为什么要指令重排序
### 11.一些说一个多线程的场景，问你如何解决

